////常函数：成员函数后加上const的函数，常函数的this指针也是const Bear*；
////1.常函数内不可以修改成员属性；
//// 常对象调用常函数，本身就不需要改变成员属性；
//// 变对象调用常函数，会将变对象的地址赋给const Bear *this，
//// 但不能通过this指针改变成员属性；(常量指针可以指向变量）
////2.成员属性在声明时加上关键字mutable后，在常函数中依然可以修改；
////常对象：在对象前加上const;
////1.可以修改常对象中mutable修饰的成员属性；
////2.常对象只能调用成员中的常函数；（静态函数只能访问静态属性）
//

//类比：
//常量指针const int*p可以指向const a;
//常量指针const int*p也可以指向变量a，但不能通过指针改变a的值；
//变量指针int*p可以指向变量，但不能指向常量；
//const int*代表通过p访问的值是不可更改的，不能随便改变；尽管指向了变量，大不了不通过指针改变变量的值就行啊；
//而int*p已经说明了可以通过p改变指向对象的值，所以不能指向常量，以防引发风险；
//对于指针常量int* const p,它是指向位置无法改变，但是仍然可以改变指向的值，因此也不能指向常量；
//#include<iostream>
//using namespace std;
//
//class Bear {
//public:
//	int m_a;
//	int m_b;
//	Bear(int a, int b)
//	{
//		m_a = a;
//		m_b = b;
//	}
//	//this指针的本质是指针常量：Bear *const this,指向一旦确定不能改变；
//	//类中常函数中的this指针：const Bear*const this，this的指向
//	// 不能改变且指向的对象不可改变；
//	void fun1() const
//	{
//		//m_a = 10;
//	}
//	int fun2()
//	{
//
//	}
//
//};
//int main()
//{
//	const Bear b1(1, 2);
//	Bear b2(3, 4);
//	b2.fun1();
//	//fun1的this指针虽然是常量指针，但可以指向变量（变对象）
//	//b1.fun2();错误
//	//fun2中的this指针是指针常量，只是指向不能变，但仍可以通过this指针，
//	// 改变this所指向的对象，为了防止修改常量对象，故规定
//	// 指针常量无法指向常量，无法指向常量对象b1;
//	const int a = 10;//a是一个常量；
//	//int*  p = &a;//错误；
//	//不能用int类指针指向常量，防止通过指针间接改变常量；
//	int b = 20;
//	const int* p1 = &b;
//	//可以用const int*类指针指向变量，一旦用const 修饰，说明p指向的
//	// 对象不能改变，大不了不通过指针间接改变变量就行，对变量没有本质影响；
//	//*p1 = 30; 错误，不能通过指针间接改变变量；
//	b = 35;
//	//int* const p2 = &a;错误；
//	return 0;
//}
